---
layout: post
title:  "NR RLC流程简介"
date:   2025-02-20 00:00:00
categories: 5G协议栈
tags: NR
excerpt: NR RLC
mathjax: true
---
* content
{:toc}
---

![KYHHbj.png](https://s2.ax1x.com/2019/10/23/KYHHbj.png)



> [博客地址](https://dufaxing.com){:target="_blank"}


# 1.RLC简介


&emsp;RLC (Radio Link Control) 层位于PDCP层 (或RRC层) 和MAC层之间。它通过RLC通道 (RLC channel) 与PDCP层(或RRC层)进行通信，并通过逻辑信道与MAC层进行通信。RLC配置是逻辑信道级的配置，一个RLC实体(RLC entity) 只对应1个UE的一个逻辑信道。RLC实体从PDCP层接收到的数据，或发往PDCP层的数据被称作RLC SDU (或PDCP PDU)。RLC实体从MAC层接收到的数据，或发往MAC层的数据被称作RLC PDU(或MAC SDU) 。
RLC层主要负责 (见38.322):。分段/重组RLC SDU (segmentation /reassembly，只适用于UM和AM模式): 在一次传输机会中，一个逻辑信道可发送的所有RLC PDU的总大小是由MAC层指定的，其大小通常并不能保证每一个需要发送的RLC SDU都能完整地发送出去，所以在发送端需要对某个RLC SDU进行分段以便匹配MAC层指定的总大小。相应地，在接收端需要对被分段的RLC SDU进行重组，以恢复出原来的RLC SDU并递送给上层。<br>

&emsp;通过ARQ进行纠错(只适用于AM模式): MAC层的HARO机制的目标在于实现非常快速的重传，其反馈出错率大概在0.1~1%左右。对于某些业务，如TCP传输(要求丢包率小于 10)，HARO反馈的出错率就显得过高了。对于这类业务，RLC层的重传处理能够进一步降低反馈出错率。

&emsp;重复包检测(duplicate detection，只适用于AM模式，UM模式不支持重复包检测): 出现重复包的最大可能性为数据的接收端反馈了HARQ ACK，但数据的发送端错误地将其解释为NACK，从而导致了不必要的MAC PDU重传。当一个RLC SDU分段需要重传，但MAC层指定的大小无法保证该RLC SDU分段完全发送出去时，就需要对该RLC SDU分段 (注意: 不是对AMD PDU进行重分段) 进行重分段处理。RLC SDU丢弃处理 (只适用于UM和AM模式): 当PDCP层指示RLC层丢弃一个特定的RLC SDU时，RLC层会触发RLC SDU丢弃处理。如果此时没有将该RLC SDU，或该RLC SDU的部分分段递交给MAC层，则AM实体发送端或UM发送端实体会丢弃指示的RLC SDU。也就是说，如果一个RLC SDU或其任意分段已经用于生成了RLC PDU，则RLC发送端不会天弃它，而是会完成该RLC SDU的传输 (这意味着AM实体发送端会持续重传该RLC SDU，直到它被对端成功接收)。当丢弃一个RLC SDU时，AM实体发送端并不会引入RLC SN间隙。<br>

&emsp;RLC重建，在切换流程中，RRC层会要求RLC层进行重建。此时RLC层会停止并重置所有定时器，将所有的状态变量重置为初始值，并丢弃所有的RLC SDU、RLC SDU分段和RLC PDU。在NR中，RLC重建时，接收端是不会往上层递送RLC SDU的。这是因为NR中的RLC层不支持重排序，只要收到一个完整的RLC SDU，就立即往上层送，所以接收端不会缓存完整的RLC SDU。(而在LTE中，RLC重建时，接收端可能往上层递送缓存中可以重组出的完整RLC SDU，并且这可能会导致PDCP层收到乱序的RLC SDU) ;

&emsp;在LTE中，只有当MAC层通知RLC实体有一个传输机会，并同时告诉RLC实体在这次传输机会中可传输的RLC PDU的总大小时，RLC层才会分段/串联RLC SDU以生成一个匹配MAC层指定大小的RLC PDU。也就是说，针对一个逻辑信道，一次传输机会只会发送一个RLC PDU，该PDU可能由一个或多个RLC SDU或RLC SDU分段组成。<br>

&emsp;但在NR中，RLC层无需等待MAC层指示的传输机会，直接将每一个RLC SDU构造成一个RLC PDU，即每个RLC SDU对应个RLC PDU (而在LTE中，通常由多个RLC SDU串联成一个RLC PDU)，RLC PDU要真正发往MAC层还是需要等待MAC层指示的传输机会。对于UM和AM模式而言，当MAC层指示的可发送的所有RLC PDU的总大小无法保证每一个需要发送的RLCSDU都能完整地发送出去时，某个RLC SDU可能被分段，并使用2个或更多个RLC PDU来传输(在不同的传输机会上)。也就是说，针对同一个逻辑信道，一次传输可能会发送多个RLC PDU，目每一个RICPDU中一个RIC SDU或RICSDU分段组成。<br>

&emsp;简单地说，在N中，对于UM和AM模式而言，RLC层MPDCP层接收到一个RLC SDU后，可立即生成一个RLC PDU(包含头部信息)，并保存在传输bufer中(即在收到MAC层指定的传输机会之前，预先生成RLC PDU，其目的是为了降低时延)。等到MAC层指示对应逻辑信道有一个传输机会，并同时指定了这次传输机会中对应逻辑信道可传输的数据量时，MAC只会将该逻辑信道对应的传输bufer中的RLC PDU串联起来。MAC层指定的大小未必能够保证参与串联的每一个RLC PDU都完整的发送出去。如果参与串联的最后一个RLC PDU大于剩余的数据量时，该RLC PDU对应的RLC SDU就需要被分段，并重新生成RLC头部以及新的RLC PDU（包含了此RLC SDU的部分数据）。也就是说，在NR中，RLC层移除了RLC SDU的电联 (conatenation) 功能 (在LTE中，允许将多个RIC SDU或RIC SDU段串联在一起生成一个RLC PDU，而这在NR中是不支持的)，而是由MAC层负责对RLC PDU进行串联，其目的是为了使RLC和MAC层能够提前进行预处理(pre-processing)，以减少处理时延。这与LTE的上行传输中，为了构造TB，RLC PDU和MAC PDU需要等接收到UL grant之后才能够生成是不同的。

&emsp;在LTE中，MAC层的HARO操作可能导致到达RLC层的报文是乱序的，所以需要RLC层对数据进行重排序(reordering)，并按序将重组后的RLC SDU发送给PDCP层，也就是说，RLC SDU n必须在RLC SDU n+1之前发送给PDCP层。但是RLC层的按序递送可能会给PDCP层的解密操作带来较大的时延。假如RLC层在SDU n之前成功接收到了SDU n+1，那么PDCP层需要等到RLC层收到RLC SDU n并递送给PDCP之后才能收到RLC SDU n+1。<br>

&emsp;在NR中，移除了RLC层的重排序功能，即RLC层不支持按序递送RLC SDU给PDCP层。RLC层在收到一个完整的RLC SDU后，就立即递送给PDCP层处理 (PDCP层可以提前做解密操作)，而无需关心之前的RLC SDU是否已经成功接收到，从而降低了RLC层的处理时延。也就是说，RLC层送往PDCP层的数据可能是乱序的，数据的按序递送(包括重排序) 由PDCP层来负责。这同时也减少了对RLC缓存的需求。对于LTE中要求按序递送的RLC协议，除非之前发送的所有RLC SDU都已被成功接收，否则不能将一个RLC SDU递送给PDCP层。这就可能导致单个丢失的RLC SDU阻止了后续RLC SDU的向上层传递，从而导致后面已接收的RLC SDU长时间留在RLC缓存中。而在NR中，完整的RLC SDU是不会缓存在接收bufer里的。

---

# 2 RLC数据过程

## 2.1 数据发送

### 2.1.1 发送端变量
这些变量由发送端的RLC实体维护，用于控制数据的发送、重传和确认。

|变量名|	全称/含义|	说明|
|---|---|---|
|TX_Next|	Next Transmission Sequence Number|	功能：这是下一个将要分配给新的、未被分段过的RLC SDU的序列号（SN）。<br>作用：每当从PDCP层收到一个新SDU，就分配当前TX_Next的值作为其SN，然后将TX_Next加1。它标志 着发送端即将使用的新SN。<br> |
|TX_Next_Ack|	Next Acknowledgement Sequence Number|	功能：这是最早的那个尚未被对端确认的RLC SDU的SN。<br>作用：所有SN < TX_Next_Ack 的PDU都已被对端正面确认（ACK）。它是发送窗口的左边界。当收到状态报告（STATUS PDU）时，会根据其中的ACK_SN来更新TX_Next_Ack，从而实现窗口滑动。<br>|
|TX_Next_Status|	Next Status Sequence Number|	功能：这是一个状态报告的有效性验证门限。<br>作用：接收端发来的STATUS PDU只有在包含ACK_SN >= TX_Next_Status时，才会被发送端认为有效并进行处理。处理完有效的状态报告后，TX_Next_Status会被更新为新的TX_Next_Ack值。这用于防止发送端处理过时或重复的状态报告。|
|POLL_SN|	Poll Sequence Number|	功能：记录最近一次因发送P=1的PDU而启动或重启t-PollRetransmit定时器时，该PDU的SN。<br>作用：用于判断是否需要触发一次新的轮询（例如，当TX_Next_Ack前进到POLL_SN时，意味着上次轮询已被应答）。|
|PDU_WITHOUT_POLL|	PDUs without a Poll|	功能：一个计数器，记录自上一次发送P=1的PDU之后，已经发送了多少个RLC数据PDU。<br>作用：当该计数器的值达到配置参数pollPDU时，发送端会在下一个PDU中将P比特置1。这是触发轮询的主要条件之一。|
|BYTE_WITHOUT_POLL|	Bytes without a Poll|	功能：一个计数器，记录自上一次发送P=1的PDU之后，已经发送了多少字节的RLC数据（仅计数据部分，不含头）。<br>作用：当该计数器的值达到配置参数pollByte时，发送端会在下一个PDU中将P比特置1。这是另一个触发轮询的主要条件。|
|t-PollRetransmit|	Poll Retransmit Timer|	功能：一个定时器。<br>作用：在发送一个P=1的PDU后启动或重启。如果在该定时器超时前未收到有效的状态报告（STATUS PDU），发送端将执行重传轮询操作（例如重传一个P=1的PDU），以防止状态报告丢失。|

### 2.1.2 发送端流程

发送端的核心是维护一个以 **`TX_Next_Ack`** 和 **`TX_Next`** 为边界的发送窗口，并管理轮询以请求状态报告。

1. **变量初始化**
    
    - `TX_Next_Ack` = 0
    - `TX_Next` = 0
    - `TX_Next_Status` = 0
    - `POLL_SN` = (未定义)
    - `pdu_without_poll` = 0
    - `byte_without_poll` = 0

note:`POLL_SN`在初始化中并未定义或者说没有意义，它的值是在发送端每次决定发送一个Poll比特置位的PDU时，被动态地赋予该PDU的序列号（SN）。

2.  **数据接收与SN分配**
    
    - 当从上层（PDCP）接收到一个RLC SDU时，发送端实体为其分配一个序列号（SN）：
        - `SN = TX_Next`

    - 随后，**`TX_Next`** 递增 1。
    - 该SDU被放入传输缓冲区，等待被处理。

3. **PDU构建与轮询决策**
    
    -   根据MAC层分配的授权大小（Grant Size），RLC实体从传输缓冲区和重传缓冲区中选择数据。
    -   **分段/串联 (Segmentation/Concatenation)**： 将SDU（或重传的PDU）分割或拼接成适合授权大小的RLC数据PDU。
    -   **设置轮询比特 (P-bit)**： 在构建PDU时，发送端根据以下规则决定是否将Poll比特置1：
        -   如果 `(pdu_without_poll >= pollPDU)` **或** `(byte_without_poll >= pollByte)` **或** （重传缓冲区不为空且 `TX_Next_Ack == POLL_SN` (窗口停滞：发现自从上次轮询后，网络就再也没有确认过任何新数据，但依然有重传数据)）等条件满足。
        -   如果决定轮询，则在该PDU中设置 `P = 1`。
            
4. **发送与缓存**
    
    - 将构建好的RLC数据PDU发送给下层（MAC）。

    - 如果是新数据（非重传），则将该PDU的副本存入**重传缓冲区 (Retransmission Buffer)**。
    -   更新计数器：
        - `pdu_without_poll`++（如果P比特未置位）
        - `byte_without_poll` += （该PDU的数据字节数）

5. **Polling 处理（轮询处理）**
    
    - 如果一个包含 `P = 1` 的PDU被发送：
        - 记录 **`POLL_SN = TX_Next - 1`** （即该PDU的SN）。
        - **启动或重启定时器 `t-PollRetransmit`**。
        - 重置计数器 `pdu_without_poll = 0` 和 `byte_without_poll = 0`。

6. **接收与处理状态报告**

    - 当从对端收到STATUS PDU时，发送端首先检查其有效性：STATUS PDU中的 `ACK_SN` 必须 >= **`TX_Next_Status`**，否则将被丢弃。
    - **处理肯定确认 (ACK)**： `ACK_SN` 指示所有 `SN < ACK_SN` 的PDU已被正确接收（除非它们在NACK\_SN列表中）。发送端将 **`TX_Next_Ack`** 更新为 `ACK_SN` 的值。**这是发送窗口的滑动**。
    - 更新 **`TX_Next_Status = TX_Next_Ack`**。
    - **处理否定确认 (NACK)**： 对于STATUS PDU中列出的每个 `NACK_SN`，发送端从重传缓冲区中找到对应的PDU（或分段）并安排重传。
    - 从重传缓冲区中删除所有 `SN < TX_Next_Ack` 的PDU。
7.  **重传超时处理 (Retransmission Timeout Handling)**
    
    -   如果定时器 **`t-PollRetransmit`** 超时，发送端执行**重传轮询**操作（例如，重新发送一个P比特置位的PDU以再次请求状态报告）。




## 2.2 数据接收

接收端变量 (Receiving Side Variables)
这些变量由接收端的RLC实体维护，用于控制数据的接收、重组、丢包检测和状态报告。

|变量名|	全称/含义|	说明|
|---|---|---|
|RX_Next|	Next Expected Reception Sequence Number|	功能：这是接收端期望按序接收的下一个RLC数据PDU的SN。<br>作用：所有SN < RX_Next 的PDU都已被按序、完整地接收并交付给上层（PDCP）。它是接收窗口的左边界，同时也是发送状态报告（STATUS PDU） 时其中ACK_SN字段的值。ACK_SN = RX_Next 告知对端：“所有SN小于这个值的PDU我都收到了”。|
|RX_Next_Highest|	Highest Received Sequence Number|	功能：记录已接收到的RLC数据PDU中的最高SN值加一（即max(SN) + 1）。<br>作用：用于检测数据包的丢失。如果RX_Next_Highest > RX_Next，则表明在RX_Next和RX_Next_Highest - 1之间存在序列号间隙，意味着有PDU丢失。|
|RX_Next_Status|	Next Status Trigger Sequence Number|	功能：这是一个状态报告的触发门限。<br>作用：用于抑制不必要的状态报告。只有当需要被NACK的SN（即丢失的PDU的SN）小于RX_Next_Status时，接收端才会触发生成并发送一个新的STATUS PDU。在发送状态报告后，会更新RX_Next_Status = RX_Next_Highest。这防止了对同一个丢失的PDU反复发送状态报告。|
|RX_Timer_Trigger|	Reassembly Timer Trigger|	功能：记录最近一次启动或重启t-Reassembly定时器时对应的RX_Next_Highest值。<br>作用：与t-Reassembly定时器配合使用。当定时器超时时，接收端会检查自定时器启动后RX_Next是否前进了。如果没有，则触发发送状态报告。|
|t-Reassembly|	Reassembly Timer|	功能：一个定时器。<br>作用：当接收端第一次检测到序列号不连续（即RX_Next_Highest > RX_Next）时启动或重启。该定时器超时表明可能发生了数据包丢失，因为它意味着在预期的时间内，缺失的PDU（RX_Next）仍未到达。超时会触发生成一个STATUS PDU来明确通知对端哪些包丢失了（NACK）。|


### **二、接收端 (Receiving Side) 流程**

接收端的核心是维护一个以 **`RX_Next`** 为下界的接收窗口，通过 **`t-Reassembly`** 定时器检测丢包，并触发状态报告。

1.  **变量初始化**

    -   `RX_Next` = 0
    -   `RX_Next_Highest` = 0
    -   `RX_Next_Status` = 0
    -   `RX_Timer_Trigger` = 0
        
2.  **接收PDU与有效性检查 (PDU Reception & Validation)**

    -   从MAC层接收RLC数据PDU。
    -   **检查SN是否在接收窗口内**： 接收端会丢弃任何 `SN < RX_Next` （完全重复）或 `SN >= RX_Next + AM_Window_Size` （超出窗口上界）的PDU。

3.  **更新状态变量与检测丢包 (Update Variables & Detect Loss)**

    -   对于接收到的有效PDU（其SN = `x`）：
        -   更新 **`RX_Next_Highest = max(RX_Next_Highest, x + 1)`**。
        -   如果 `x >= RX_Next`，表明存在序列号间隙，可能发生了丢包。

4.  **重组与按序交付 (Reassembly & In-Sequence Delivery)**
    
    -   将接收到的PDU（可能是分段）放入**重组缓冲区 (Reassembly Buffer)**。
    -   检查是否所有属于 `SN = RX_Next` 的SDU的分段都已到达并被完整重组。
    -   **如果重组完成**，则将完整的RLC SDU按序交付给上层（PDCP），并递增 **`RX_Next`**。
    -   递交后，继续检查新的 `RX_Next` 对应的SDU是否也已完整，如果是，则继续交付并递增，直到遇到一个缺失的SDU为止。

5.  **重组定时器管理 (Reassembly Timer Management)**
    
    -   当接收端第一次检测到 `RX_Next_Highest > RX_Next` （即发生不连续）时，会：
        -   **启动或重启定时器 `t-Reassembly`**。
        -   设置 **`RX_Timer_Trigger = RX_Next_Highest`**。
    -   如果 **`t-Reassembly`** 超时，接收端将**触发生成一个STATUS PDU**。

6.  **生成与发送状态报告 (STATUS PDU Generation & Transmission)**
    
    -   状态报告的触发条件包括：
        -   `t-Reassembly` 超时。
        -   收到对端发送的 `P=1` 的PDU（轮询请求）。
        -   检测到自身接收缓冲区即将满等其他实现相关条件。
    -   **构建STATUS PDU**：
        -   将 **`ACK_SN`** 字段设置为 **`RX_Next`** 的当前值。这告知对端所有 `SN < ACK_SN` 的PDU已被正确接收。
        -   在NACK\_SN列表中，列出所有小于 `ACK_SN` 但接收端检测到丢失（未收到或错误接收）的SN。
    -   在发送STATUS PDU之前，更新 **`RX_Next_Status = RX_Next_Highest`**。这个变量用于防止过早地重复发送相同的状态报告（只有当新的丢失SN `< RX_Next_Status` 时才会再次触发）。
        

这个过程确保了数据的可靠、按序传输，其核心逻辑通过上述变量及其相互作用得以实现。



## 2.3小结

- **发送窗口**：由 **`TX_Next_Ack`** （左边界）和 **`TX_Next_Ack + AM_Window_Size`** （右边界）定义。**`TX_Next`** 必须在这个窗口内移动。

- **接收窗口**：由 **`RX_Next`** （左边界）和 **`RX_Next + AM_Window_Size`** （右边界）定义。任何SN超出此范围的PDU都会被丢弃。

- **可靠性机制**：
    - **发送端**通过 **`pdu/byte_without_poll`** 和 **`t-PollRetransmit`** 来**主动请求**（轮询）状态报告。
    - **接收端**通过 **`RX_Next_Highest`** 和 **`t-Reassembly`** 来**被动检测**丢包，并触发状态报告作为响应。
- **状态报告**：是沟通收发双方状态的核心信令。其有效性（发送端）和触发条件（接收端）分别由 **`TX_Next_Status`** 和 **`RX_Next_Status`** 严格控制，确保了机制的效率和鲁棒性。
    

这些变量共同构成了RLC AM模式的自动重传请求（ARQ）引擎，确保了数据在不可靠的无线信道上的可靠传输。




---
