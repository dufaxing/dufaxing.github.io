---
layout: post
title:  "传指针与传引用的区别"
date:   2018-1-24 00:00:00
categories: 嵌入式
tags: C语言
excerpt: 传引用等价于，扩大了原对象的作用域。
mathjax: true
---
* content
{:toc}
---

**指针传递参数本质上是值传递的方式，它所传递的是一个地址值。**
值传递过程中，**被调函数的形式参数作为被调函数的局部变量处理，** 即在栈中开辟了内存空间以存放由主调函数放进来的实参的值，从而成为了实参的一个副本。值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。（这里是在说实参指针本身的地址值不会变）<br/>
<br/>
而在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，**但是这时存放的是由主调函数放进来的实参变量的地址（int &a的形式）。**  被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。

<br/>
引用传递和指针传递是不同的，虽然它们都是在被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。而对于指针传递的参数，如果改变被调函数中的指针地址，它将影响不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量，那就得使用指向指针的指针，或者指针引用。

从编译的角度来阐述它们之间的区别：<br/>
程序在编译时分别将指针和引用添加到符号表上，符号表上记录的是变量名及变量所对应地址。指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值。符号表生成后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），而引用对象则不能修改。<br/>
<br/>
<br/>
最后，总结一下指针和引用的相同点和不同点：<br/>
- ★相同点：<br/>
  ●都是地址的概念；
指针指向一块内存，它的内容是所指内存的地址；而引用则是某块内存的别名。<br/>
- ★不同点：<br/>
  ●指针是一个实体，而引用仅是个别名；<br/>
  ●引用只能在定义时被初始化一次，之后不可变；指针可变；引用“从一而终”，指针可以“见异思迁”；<br/>
  ●引用没有const，指针有const，const的指针不可变；（具体指没有int& const a这种形式，而const int& a是有     的，  前者指引用本身即别名不可以改变，这是当然的，所以不需要这种形式，后者指引用所指的值不可以改变）<br/>
  ●引用不能为空，指针可以为空；<br/>
  ●`sizeof 引用`得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小；<br/>
  ●指针和引用的自增(++)运算意义不一样；<br/>
  ●引用是类型安全的，而指针不是 (引用比指针多了类型检查<br/>

<br/>
<br/>

注：如果不用引用的话，被传递的参数本身是不能被修改的，即使你传递的是指针，也只能修改指针指向的内容，不能修改指针本身。如果要修改当前被传递的参数的话，要么再加一级指针，要么用引用。
<br/>

---

- 实参与形参<br/>
    - 形参出现在函数定义中，在整个函数体内都可以使用， 离开该函数则不能使用。实参出现在主调函数中，进入被调函数后，实参变量也不能使用。 形参和实参的功能是作数据传送。发生函数调用时， 主调函数把实参的值传送给被调函数的形参从而实现主调函数向被调函数的数据传送。<br/>
    - 形参变量只有在被调用时才分配内存单元，在调用结束时， 即刻释放所分配的内存单元。因此，形参只有在函数内部有效。 函数调用结束返回主调函数后则不能再使用该形参变量。<br/>
    
    
---



````
void swap(&x,&y)
{
    int t =x;
    x = y;
    y = t;
}
int main()
{
    int x,y;
    swap(x,y);//等价于 t = x; x= y; y =t;扩大了原对象的作用域。
}
```